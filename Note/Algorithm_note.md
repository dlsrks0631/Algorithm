# 복잡도

* 일반적으로 파이썬 프로그램에서는 2,000만번 ~ 1억 번의 연산을 1초에 수행 시간으로 예측할 수 있다
* 시간 복잡도 유형
1. 빅-오메가: 최선일 때 연산 횟수를 나타낸 표기법
2. 빅-세타: 보통일 때 연산 횟수를 나타낸 표기법
3. 빅-오: 최악일 때 연산 횟수를 나타낸 표기법
* 모든 케이스를 통과해야하므로 시간 복잡도를 판단할 때는 최악일 때를 염두에 둠

* 시간 복잡도 도출 기준
1. 상수는 시간 복잡도 계산에서 제외함
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 됨

* 시간제한에 따른 알고리즘 설계
- 500               O(N^3)
- 2,000             O(N^2)
- 100,000(10만)     O(NLogN)
- 10,000,000(1천만)  O(N)

* 수행 시간 측정
```
import time
start_time = time.time() # 측정 시작

end_time = time.time()
print('time:', end_time - start_time) # 수행 시간 출력
```

# 구간합

# 투 포인터
* 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘
* 시간 복잡도
- 매 루프마다 항상 두 포인터 중 하나는 1씩 증가하고 각 포인터가 n번 누적 증가해야 알고리즘이 끝남 > O(N)

(ex) 연속된 자연수의 합 구하기 (BOJ2018)
```
import sys

input = sys.stdin.readline

n = int(input())

start_index = 1
end_index = 1
sum = 1
count = 1

while end_index != n:
    if sum == n:
        count += 1
        end_index += 1
        sum += end_index
    elif sum > n:
        sum -= start_index
        start_index += 1   
    else:
        end_index += 1
        sum += end_index

print(count)

```

# 슬라이딩 윈도우(Sliding Window)

* 2개의 포인터로 범위를 지정한 다음, 범위(window)를 유지한 채로 이동(sliding)하며 해결 > 투 포인터 알고리즘과 매우 비슷
* 리스트나 배열 등의 자료구조를 사용하여 구간 내에서의 데이터를 관리하는 경우에 구간의 양쪽 끝을 다루는 데 유용한 덱(Deque)을 사용하기도 함
1. 구간 내에서 연속된 k개의 데이터를 관리할 때: 구간 내에서 데이터를 삽입하거나 삭제할 때, 리스트에서는 데이터를 한 칸씩 이동시켜야 하지만 덱에서는 삽입과 삭제가 O(1)의 시간복잡도로 가능하다
2. 구간 내에서의 최소값, 최대값 등 특정 조건을 만족하는 데이터를 찾을 때: 슬라이싱 윈도우에서는 구간 내에서 특정 조건을 만족하는 데이터를 찾는 경우가 많은데, 덱에서는 최소값, 최대값 등을 O(1)의 시간복잡도로 찾을 수 있다

3. 슬라이딩 윈도우의 크기가 고정되어 있지 않은 경우
만약 슬라이딩 윈도우의 크기가 고정되어 있지 않아 윈도우의 크기가 변하는 경우라면, 덱을 사용하여 슬라이딩 윈도우의 크기를 동적으로 조절할 수 있습니다. 이를 통해 윈도우 크기에 따라 새로운 요소를 추가하거나 기존 요소를 제거하는 작업을 효율적으로 수행할 수 있습니다.

4. 윈도우 내의 요소를 순서대로 접근할 필요가 없는 경우
일반적으로 슬라이딩 윈도우는 윈도우 내의 요소를 순서대로 접근하여 조건을 검사합니다. 하지만, 윈도우 내의 요소를 순서대로 접근할 필요가 없는 경우라면, 덱을 사용하여 윈도우 내의 요소를 임의로 접근할 수 있습니다. 이를 통해 윈도우 내의 요소를 효율적으로 관리할 수 있습니다.

5. 슬라이딩 윈도우 내에서 최대값 또는 최소값을 찾는 경우
슬라이딩 윈도우 내에서 최대값 또는 최소값을 찾는 문제라면, 덱을 사용하여 최대값 또는 최소값을 효율적으로 관리할 수 있습니다. 이를 통해 최대값 또는 최소값을 찾는 작업을 O(1)의 시간 복잡도로 수행할 수 있습니다.

# 스택
* 삽입과 삭제 연산이 후입선출로 이뤄지는 자료구조
* 삽입과 삭제가 한 쪽에서만 일어나는 특징
- top: 삽입과 삭제가 일어나는 위치
- s.append(data): top 위치에 새로운 데이터를 삽입하는 연산
- s.pop(): top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
- s[-1]: top 위치에 현재 있는 데이터를 단순 확인하는 연산


# 큐
* 삽입과 삭제 연산이 선입선출로 이뤄지는 자료구조
* 스택과 다르게 먼저 들어온 데이터가 먼저 나가며 삽입과 삭제가 양방향에서 이뤄짐
- rear: 큐에서 가장 끝 데이터를 가리키는 영역
- front: 큐에서 가장 앞의 데이터를 가리키는 영역
- s.append(data): rear 부분에 새로운 데이터를 삽입하는 연산
- s.popleft(): front 부분에 있는 데이터를 삭제하고 확인하는 연산
- s[0]: 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산

# 덱
* 스택과 큐를 합친 자료구조
* 양쪽 끝에서 삽입과 삭제가 모두 가능하며, 스택과 큐의 연산을 모두 지원
* 즉, 리스트와 비슷하게 인덱싱과 슬라이싱도 가능하지만, 리스트보다 빠른 속도 보장
(ex)
```
from collections import deque

dq = deque([1, 2, 3])
dq.append(4)          # 오른쪽에 추가
dq.appendleft(0)      # 왼쪽에 추가
dq.pop()              # 오른쪽에서 삭제
dq.popleft()          # 왼쪽에서 삭제
dq.rotate(1)          # 오른쪽으로 1칸 이동
dq.rotate(-1)         # 왼쪽으로 1칸 이동
```

# 우선순위 큐
* 데이터를 저장하고 꺼낼 때 우선순위를 고려하는 자료구조
* 파이썬에서는 우선순위 큐를 구현하기 위해 'heapq'모듈 제공
* 삽입 및 삭제에 대한 시간복잡도: O(nlogn)
* 'heappush' 함수로 요소를 추가하고 'heappop'함수로 최소값을 꺼낼 수 있다
* 'heappushpop' 함수는 새로운 요소를 추가하고 최소값을 꺼내는 연산을 동시에 수행할 수 있다(heappush()와 heappop() 함수를 순서대로 호출하는 것과 같은 기능) 하지만 더 빠름
(ex)
```
import heapq

heap = [3, 5, 7, 9]
min_val = heapq.heappushpop(heap, 1)
print(min_val)  # 1
print(heap)  # [3, 5, 7, 9]

min_val = heapq.heappushpop(heap, 4)
print(min_val)  # 3
print(heap)  # [4, 5, 7, 9]
```
* 'heapify' 함수를 사용하여 리스트를 최소 힙으로 변환할 수 있다
(ex)
```
import heapq

q = []
heapq.heappush(q, 3)
heapq.heappush(q, 1)
heapq.heappush(q, 4)
heapq.heappush(q, 2)

while q:
    print(heapq.heappop(q))  # 1 2 3 4 출력
```

# PriorityQueue
* 파이썬의 내장 모듈인 'queue'모듈에서 제공하는 우선순위 큐 구현체
* 일반적인 큐와 달리 요소를 우선순위에 따라 정렬하여 처리하는 자료구조
- 즉, 가장 높은 우선순위를 가진 요소가 가장 먼저 처리됨
* 'put()' 메서드로 요소를 추가
* 'get()' 메서드로 요소를 가져올 때는 우선순위가 가장 높은 요소가 반환되며, 동시에 큐에서 삭제됨
(ex)
```
import queue

q = queue.PriorityQueue()

# 차례대로 우선순위
q.put((1, 'carrot'))
q.put((1, 'banana'))
q.put((3, 'orange'))

print(q.get()) # (1,banana)

while not q.empty():
    print(q.get()[1])  # carrot orange 


```

# 정렬

## 정렬 - 버블정렬
* 시간복잡도: O(n^2)
* 데이터의 인접요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식으로 다른 정렬 알고리즘보다 속도가 느린 편에 속함
* 버블정렬의 과정
    1. 비교 연산이 필요한 루프 범위 설정
    2. 인접한 데이터 값을 비교
    3. swap 조건에 부합하면 swap 연산을 수행
    4. 루프 범위가 끝날 때까지 2~3을 반복
    5. 정렬 영역을 설정, 다음 루프를 실행할 때는 이 영역을 제외한다
    6. 비교 대상이 없을 때까지 1~5를 반복한다 
    > 만약 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료해도 됨

## 정렬 - 선택정렬
* 시간복잡도: O(n^2)
* 최솟값(오름차순 정렬) 또는 최댓값(내림차순 정령)을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 방법
* 최대나 최소 데이터를 데이터가 나열한 순으로 찾아가며 선택하는 방법
* 구현 방법이 복잡하고 시간복잡도가 효율적이지 않아 많이 사용 X

# 정렬 - 퀵정렬

# 정렬 - 병합정렬

# 정렬 - 기수정렬


# 탐색 - DFS 깊이우선탐색
* 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘